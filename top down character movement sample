<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Dot Behavior with Projectiles and Fixed Camera</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #222;
    }
    canvas {
      display: block;
    }
    /* Dark mode panel in top left */
    #colorPanel {
      position: fixed;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 10px;
      border-radius: 5px;
      z-index: 10;
      font-family: sans-serif;
      font-size: 14px;
    }
    #colorPanel label {
      margin-right: 5px;
    }
    #colorPanel div {
      margin-bottom: 5px;
    }
  </style>
  <!-- Three.js library -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <!-- OrbitControls -->
  <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>
  <!-- Dark Mode Panel -->
  <div id="colorPanel">
    <div>
      <label for="dotColorPicker">Color:</label>
      <!-- Default color changed to bright blue (#009EFF) -->
      <input type="color" id="dotColorPicker" value="#009EFF">
    </div>
  </div>

  <script>
    let currentDotColor = "#009EFF";

    // ----- Scene, Camera, Renderer -----
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(
      75, window.innerWidth / window.innerHeight, 0.1, 3000
    );
    camera.position.set(0, 200, 500);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Prevent the context menu from appearing on right-click.
    renderer.domElement.addEventListener('contextmenu', (event) => {
      event.preventDefault();
    });

    // ----- Create the Player Dot First -----
    const dotGeo = new THREE.SphereGeometry(5, 16, 16);
    const dotMat = new THREE.MeshLambertMaterial({ color: new THREE.Color(currentDotColor) });
    const dot = new THREE.Mesh(dotGeo, dotMat);
    scene.add(dot);
    dot.position.set(0, 5, 0); // Hovering slightly above the ground

    // ----- OrbitControls (Modified) -----
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    // Disable panning so the camera doesn't slide sideways.
    controls.enablePan = false;
    // Configure the mouse buttons so that only the right button rotates.
    controls.mouseButtons = {
      ORBIT: THREE.MOUSE.RIGHT,
      ZOOM: THREE.MOUSE.MIDDLE,
      PAN: null
    };

    // Set the OrbitControls target to the dot.
    controls.target.copy(dot.position);

    // Lock vertical rotation (only allow turning left/right).
    // Compute the current polar angle from the dot to the camera.
    const offset = new THREE.Vector3().subVectors(camera.position, dot.position);
    const polarAngle = Math.acos(offset.y / offset.length());
    controls.minPolarAngle = polarAngle;
    controls.maxPolarAngle = polarAngle;

    // ----- Lighting -----
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(0, 500, 200);
    scene.add(directionalLight);

    // ----- Ground (Large Floor) -----
    const floorSize = 2000;
    const floorGeo = new THREE.PlaneGeometry(floorSize, floorSize);
    const floorMat = new THREE.MeshLambertMaterial({ color: 0x444444, side: THREE.DoubleSide });
    const floor = new THREE.Mesh(floorGeo, floorMat);
    floor.rotation.x = - Math.PI / 2;
    scene.add(floor);

    // (Optional) Also add a grid helper for visual reference.
    const gridHelper = new THREE.GridHelper(floorSize, 50);
    scene.add(gridHelper);

    // ----- Movement Controls for the Dot -----
    const speed = 5;
    let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;

    window.addEventListener('keydown', (event) => {
      if (event.key === 'w') moveForward = true;
      if (event.key === 's') moveBackward = true;
      if (event.key === 'a') moveLeft = true;
      if (event.key === 'd') moveRight = true;
    });

    window.addEventListener('keyup', (event) => {
      if (event.key === 'w') moveForward = false;
      if (event.key === 's') moveBackward = false;
      if (event.key === 'a') moveLeft = false;
      if (event.key === 'd') moveRight = false;
    });

    function moveDot() {
      // Compute camera's horizontal forward vector.
      const forward = new THREE.Vector3();
      camera.getWorldDirection(forward);
      forward.y = 0;
      forward.normalize();

      // Compute right vector from camera.
      const right = new THREE.Vector3();
      right.crossVectors(forward, camera.up).normalize();

      let moveVector = new THREE.Vector3();
      if (moveForward) moveVector.add(forward);
      if (moveBackward) moveVector.sub(forward);
      if (moveRight) moveVector.add(right);
      if (moveLeft) moveVector.sub(right);

      if (moveVector.length() > 0) {
        moveVector.normalize();
        const delta = moveVector.clone().multiplyScalar(speed);
        // Move the dot.
        dot.position.add(delta);
        // Also translate the camera by the same delta so the offset remains fixed.
        camera.position.add(delta);
        // Update the OrbitControls target.
        controls.target.copy(dot.position);
      }
    }

    // ----- Projectile Logic -----
    const projectiles = [];
    const gravity = 0.3;
    const bounceDamping = 0.7;
    const friction = 0.98; // Horizontal friction on bounce

    function createProjectile(startPos, direction) {
      const projectileRadius = 3;
      const projectileGeo = new THREE.SphereGeometry(projectileRadius, 8, 8);
      // Use the current dot color; enable transparency for fading.
      const projectileMat = new THREE.MeshLambertMaterial({ color: currentDotColor, transparent: true, opacity: 1 });
      const projectileMesh = new THREE.Mesh(projectileGeo, projectileMat);
      projectileMesh.position.copy(startPos);

      // Give the projectile an initial speed.
      const projectileSpeed = 15;
      const velocity = direction.clone().multiplyScalar(projectileSpeed);

      const projectile = {
        mesh: projectileMesh,
        velocity: velocity,
        bounceCount: 0,
        radius: projectileRadius
      };

      projectiles.push(projectile);
      scene.add(projectileMesh);
    }

    // On a left click, shoot a projectile from the player's dot.
    renderer.domElement.addEventListener('click', (event) => {
      // Calculate normalized device coordinates.
      const rect = renderer.domElement.getBoundingClientRect();
      const mouse = new THREE.Vector2(
        ((event.clientX - rect.left) / rect.width) * 2 - 1,
        -((event.clientY - rect.top) / rect.height) * 2 + 1
      );

      // Set up a raycaster using the mouse coordinates.
      const raycaster = new THREE.Raycaster();
      raycaster.setFromCamera(mouse, camera);

      // Define a ground plane at y = 0.
      const groundPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
      const intersectionPoint = new THREE.Vector3();
      raycaster.ray.intersectPlane(groundPlane, intersectionPoint);

      // Determine the direction from the player's dot to the intersection point.
      const projectileDirection = new THREE.Vector3().subVectors(intersectionPoint, dot.position).normalize();
      // Add an upward boost so the projectile makes a nice arc.
      projectileDirection.y += 0.3;
      projectileDirection.normalize();

      createProjectile(dot.position.clone(), projectileDirection);
    });

    // Update each projectile's motion.
    function updateProjectiles() {
      for (let i = projectiles.length - 1; i >= 0; i--) {
        const p = projectiles[i];
        // Apply gravity.
        p.velocity.y -= gravity;
        // Update position.
        p.mesh.position.add(p.velocity);

        // Check collision with the ground.
        if (p.mesh.position.y <= p.radius) {
          p.mesh.position.y = p.radius;
          p.velocity.y = -p.velocity.y * bounceDamping;
          p.velocity.x *= friction;
          p.velocity.z *= friction;
          p.bounceCount++;

          // After a few bounces, start fading out the projectile.
          if (p.bounceCount >= 3) {
            p.mesh.material.opacity -= 0.02;
          }
        }

        // Remove projectile if fully faded.
        if (p.mesh.material.opacity <= 0) {
          scene.remove(p.mesh);
          projectiles.splice(i, 1);
        }
      }
    }

    // ----- Update Dot Color from the Color Picker -----
    const colorPicker = document.getElementById("dotColorPicker");
    colorPicker.addEventListener("input", (event) => {
      currentDotColor = event.target.value;
      dot.material.color.set(currentDotColor);
    });

    // ----- Animation Loop -----
    function animate() {
      requestAnimationFrame(animate);
      
      moveDot();           // Update the player dot (and camera) position.
      updateProjectiles(); // Update any active projectiles.

      controls.update();
      renderer.render(scene, camera);
    }

    animate();

    // ----- Window Resize Handling -----
    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
